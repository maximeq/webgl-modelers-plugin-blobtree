!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = t(
  require("webgl-modelers"),
  require("three-full"),
  require("backbone"),
  require("three-js-blobtree")
  ))
: "function" == typeof define && define.amd
? define(["webgl-modelers", "three-full", "backbone", "three-js-blobtree"], t)
: (e.WebGLModelersPluginBlobtree = t(
  e.WebGLModelers,
  e.THREE,
  e.Backbone,
  e.Blobtree
  ));
})(this, function(e, t, r, o) {
"use strict";
(e = e && e.hasOwnProperty("default") ? e.default : e),
(t = t && t.hasOwnProperty("default") ? t.default : t),
(r = r && r.hasOwnProperty("default") ? r.default : r),
(o = o && o.hasOwnProperty("default") ? o.default : o);
var s = {
code: [
"self.onmessage = function(e){",
"   self.processId = e.data.processId;",
"   self.blobtree = Blobtree.Types.fromJSON(e.data.blobtree);",
"   self.blobtree.prepareForEval()",
"   var progress = function (percent) {",
"       self.postMessage({",
"           cmd:'progress',",
"           processId:self.processId,",
"           percent:percent",
"       });",
"   };",
"   var split_max = false;",
"   var smc = null;",
"   if(split_max){",
"       smc = new Blobtree.SplitMaxPolygonizer(",
"           self.blobtree,",
"           {",
"               subPolygonizer:{",
"                   class:Blobtree.SlidingMarchingCubes,",
"                   convergence:{step:4},",
"                   detailRatio: 1.0",
"               },",
"               progress:progress",
"           }",
"       );",
"   }else{",
"       smc = new Blobtree.SlidingMarchingCubes(",
"           self.blobtree,",
"           {",
"               convergence:{step:4},",
"               detailRatio: 1.0,",
"               progress:progress",
"           }",
"       );",
"   }",
"   var g = smc.compute();",
"   var buffers = {",
"       position:g.getAttribute('position').array,",
"       normal:g.getAttribute('normal').array,",
"       color:g.getAttribute('color').array,",
"       index:g.getIndex().array",
"   };",
"   self.postMessage({",
"       cmd:'geometry',",
"       processId:self.processId,",
"       buffers:buffers,",
"       transferList:[buffers.position, buffers.normal, buffers.color, buffers.index]",
"   });",
"}"
].join("\n"),
create: function(e) {
for (var t = {}, r = "window = {};\n", o = 0; o < e.libpaths.length; ++o) {
var i = e.libpaths[o];
(r += "importScripts('" + i.url + "');\n"),
"threejs" === i.name && (r += "var THREE = THREE || Three;\n"),
(t[i.name] = !0);
}
if (!t.threejs)
throw "Error : SimpleSMCWorker needs lib THREE.JS imported with name threejs in libpaths.";
if (!t.blobtreejs)
throw "Error : SimpleSMCWorker needs lib THREE.JS imported with name blobtreejs in libpaths.";
var n = s.code;
return (
e.splitMax &&
(n = n.replace("var split_max = false;", "var split_max = true;")),
new Worker(URL.createObjectURL(new Blob([r + n])))
);
}
},
i = s;
const n = (window && window.Blobtree) || o,
l = e.GSTATUS;
var a,
u = r.Model.extend({
initialize: function(e, r) {
(this.blobtree = new n.RootNode()),
(this.blobGeom = new t.BufferGeometry()),
this.blobGeom.addAttribute(
"position",
new t.BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]), 3)
),
(this.gStatus = l.OUTDATED),
(this.processTimeout = null),
(this.processId = null),
(this.workerize = r.workerize),
this.workerize && ((this.worker = null), (this.libpaths = r.libpaths)),
(this.splitMaxPolygonizer = r.splitMaxPolygonizer || !1);
var o = this;
setTimeout(function() {
o._setGStatus(l.UP_TO_DATE);
});
},
toJSON: function() {
return this.blobtree.toJSON();
},
fromJSON: function(e) {
(this.blobtree = n.Types.fromJSON(e)), this._invalidGeometry();
},
getBlobtree: function() {
return this.blobtree;
},
setBlobtree: function(e) {
(this.blobtree = e), this._invalidGeometry();
},
addBlobtreeElement: function(e, t) {
(t = t || this.blobtree).addChild(e), this._invalidGeometry();
},
_invalidGeometry: function() {
clearTimeout(this.processTimeout),
(this.processTimeout = null),
this.clearWorker(),
(this.processId = null),
this._setGStatus(l.OUTDATED);
},
getGStatus: function() {
return this.gStatus;
},
_setGStatus: function(e, t) {
if (this.gStatus !== e) {
var r = {
type: "gStatusChanged",
old: this.gStatus,
new: e,
geometry: this.blobGeom,
name: "blobtree"
};
(this.gStatus = e), this.trigger(r.type, r);
}
if (e === l.COMPUTING) {
r = {type: "gComputingProgressChanged", name: "blobtree", percent: t};
this.trigger(r.type, r);
}
},
_generateProcessID:
((a = null),
function() {
for (var e = new Date().getTime(); e === a; ) e = new Date().getTime();
return (a = e), e;
}),
clearWorker: function() {
this.worker && (this.worker.terminate(), (this.worker = null));
},
updateGeometries: function() {
if (this.gStatus === l.UP_TO_DATE) return null;
if (this.gStatus === l.OUTDATED) {
(this.processId = this._generateProcessID()), this._setGStatus(l.COMPUTING, 0);
var e = this;
return (
this.workerize
? ((this.worker = i.create({
  libpaths: this.libpaths,
  splitMax: this.splitMaxPolygonizer
  })),
  (this.worker.onmessage = function(r) {
  var o = r.data;
  "geometry" === o.cmd &&
  e.processId === o.processId &&
  (e._setGStatus(l.COMPUTING, 100),
  (e.blobGeom = new t.BufferGeometry()),
  e.blobGeom.addAttribute(
  "position",
  new t.BufferAttribute(o.buffers.position, 3)
  ),
  e.blobGeom.addAttribute("normal", new t.BufferAttribute(o.buffers.normal, 3)),
  e.blobGeom.addAttribute("color", new t.BufferAttribute(o.buffers.color, 3)),
  e.blobGeom.setIndex(new t.BufferAttribute(o.buffers.index, 1)),
  e.blobGeom.computeBoundingBox(),
  e.clearWorker(),
  (e.processId = null),
  e._setGStatus(l.UP_TO_DATE)),
  "progress" === o.cmd && e._setGStatus(l.COMPUTING, o.percent);
  }),
  setTimeout(
  ((r = e.processId),
  (o = e.blobtree.toJSON()),
  function() {
  e.worker &&
  e.worker.postMessage({cmd: "polygonize", blobtree: o, processId: r});
  }),
  0
  ))
: (this.processTimeout = setTimeout(function() {
  var t = null;
  (t = this.splitMaxPolygonizer
  ? new n.SplitMaxPolygonizer(e.blobtree, {
    subPolygonizer: {
    class: n.SlidingMarchingCubes,
    convergence: {step: 4},
    detailRatio: 1
    }
    })
  : new n.SlidingMarchingCubes(e.blobtree, {
    convergence: {step: 4},
    detailRatio: 1
    })),
  (e.blobGeom = t.compute()),
  e.blobGeom.computeBoundingBox(),
  clearTimeout(e.processTimeout),
  (e.processId = null),
  e._setGStatus(l.UP_TO_DATE);
  }, 0)),
this.processId
);
}
return (
console.log(
"Geometry is already computing and has not been set to outdated, updateGeometries is waiting for current computation result."
),
this.processId
);
var r, o;
}
});
const b = e.SceneManager;
var c,
p,
f,
d = function(e) {
b.call(this, e),
(this.emptyG = new t.BufferGeometry()),
this.emptyG.addAttribute(
"position",
new t.BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]), 3)
);
var r = new t.Mesh(this.emptyG, this.surfaceMat);
(r.receiveShadow = !0),
(r.castShadow = !0),
(r.name = "blobtree"),
this.addMesh(r);
};
((d.prototype = Object.create(b.prototype)).constructor = d),
(d.prototype.getSceneIntersections =
((c = new t.Vector3()),
(p = new t.Vector3()),
(f = new t.Vector3()),
function(e, r) {
var o = this.model.getBlobtree();
if (o) {
o.prepareForEval(), o.getAABB().getSize(c), o.getAABB().getCenter(p);
var s = {v: 0, g: new t.Vector3(), step: 0};
if (
(f.subVectors(e.origin, p),
o.intersectRayBlob(e, s, f.length() + c.x + c.y + c.z, r || 0.001))
)
return [
{
distance: s.distance,
object: this.meshGroup.getObjectByName("blobtree"),
point: s.point,
gradient: s.g
}
];
}
return [];
})),
(d.prototype.clearBlobtreeMesh = function() {
this.meshGroup.getObjectByName("blobtree").geometry.dispose(),
(this.meshGroup.getObjectByName("blobtree").geometry = this.emptyG),
this.requireRender();
});
var h = d;
return (
(e.Plugins.Blobtree = {
SimpleSMCWorker: i,
BlobtreeSceneManager: h,
BlobtreeModel: u
}),
Object.keys(e.Plugins.Blobtree).forEach(function(t) {
e.Plugins.Blobtree[t], (e[t] = e.Plugins.Blobtree[t]);
}),
e
);
});
